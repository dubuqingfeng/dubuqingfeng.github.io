<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>独步清风's blog</title><link>dubuqingfeng.github.io/</link><description></description><atom:link href="dubuqingfeng.github.io/feeds/dian-zi-she-ji.rss.xml" rel="self"></atom:link><lastBuildDate>Fri, 10 Apr 2015 20:18:00 +0200</lastBuildDate><item><title>基于XXX的解魔方机器人软件设计与实现</title><link>dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-Ruanjiansheji.html</link><description>&lt;h5&gt;0x01 Android上位机设计部分&lt;/h5&gt;
&lt;p&gt;常见的魔方比赛可以&lt;/p&gt;
&lt;h5&gt;0x02 Android代码思路&lt;/h5&gt;
&lt;h5&gt;0x03 Android软件测试&lt;/h5&gt;
&lt;h5&gt;0x04 Arduino测试代码思路&lt;/h5&gt;
&lt;p&gt;首先通过官方示例程序Knob和Sweep测试舵机运行情况&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* &lt;/span&gt;
&lt;span class="cm"&gt; Controlling a servo position using a potentiometer (variable resistor) &lt;/span&gt;
&lt;span class="cm"&gt; by Michal Rinott &amp;lt;http://people.interaction-ivrea.it/m.rinott&amp;gt;&lt;/span&gt;

&lt;span class="cm"&gt; modified on 8 Nov 2013&lt;/span&gt;
&lt;span class="cm"&gt; by Scott Fitzgerald&lt;/span&gt;
&lt;span class="cm"&gt; http://arduino.cc/en/Tutorial/Knob&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;Servo.h&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;Servo&lt;/span&gt; &lt;span class="n"&gt;myservo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// create servo object to control a servo&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;potpin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// analog pin used to connect the potentiometer&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// variable to read the value from the analog pin&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;myservo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// attaches the servo on pin 9 to the servo object&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;analogRead&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;potpin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// reads the value of the potentiometer (value between 0 and 1023) &lt;/span&gt;
  &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1023&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;180&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// scale it to use it with the servo (value between 0 and 180) &lt;/span&gt;
  &lt;span class="n"&gt;myservo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                  &lt;span class="c1"&gt;// sets the servo position according to the scaled value &lt;/span&gt;
  &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                           &lt;span class="c1"&gt;// waits for the servo to get there &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Sweep&lt;/span&gt;
&lt;span class="cm"&gt; by BARRAGAN &amp;lt;http://barraganstudio.com&amp;gt; &lt;/span&gt;
&lt;span class="cm"&gt; This example code is in the public domain.&lt;/span&gt;

&lt;span class="cm"&gt; modified 8 Nov 2013&lt;/span&gt;
&lt;span class="cm"&gt; by Scott Fitzgerald&lt;/span&gt;
&lt;span class="cm"&gt; http://arduino.cc/en/Tutorial/Sweep&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;Servo.h&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;Servo&lt;/span&gt; &lt;span class="n"&gt;myservo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// create servo object to control a servo &lt;/span&gt;
                &lt;span class="c1"&gt;// twelve servo objects can be created on most boards&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// variable to store the servo position &lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;myservo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// attaches the servo on pin 9 to the servo object &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;180&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// goes from 0 degrees to 180 degrees &lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;                                  &lt;span class="c1"&gt;// in steps of 1 degree &lt;/span&gt;
    &lt;span class="n"&gt;myservo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// tell servo to go to position in variable &amp;#39;pos&amp;#39; &lt;/span&gt;
    &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                       &lt;span class="c1"&gt;// waits 15ms for the servo to reach the position &lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;180&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// goes from 180 degrees to 0 degrees &lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;myservo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// tell servo to go to position in variable &amp;#39;pos&amp;#39; &lt;/span&gt;
    &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                       &lt;span class="c1"&gt;// waits 15ms for the servo to reach the position &lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;0x05 Arduino代码&lt;/h5&gt;
&lt;p&gt;Arduino代码部分在github上也可找到，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用串口测试成对舵机的代码--&amp;gt;DoubleServo&lt;/p&gt;
&lt;p&gt;约定一些操作码和公式进行方便控制舵机的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;0x05 计算解法公式&lt;/h5&gt;
&lt;p&gt;涉及到魔方解法部分，&lt;/p&gt;
&lt;h5&gt;0x06 蓝牙发送操作码&lt;/h5&gt;
&lt;p&gt;分为普通公式与特定操作码部分，普通公式主要为使用二阶段算法计算出来的解法公式，并且约定带+号为顺时针旋转，带-号为逆时针旋转，特定操作码约定一些特定的舵机控制操作，主要以下列表所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全部还原固定角度&lt;/p&gt;
&lt;p&gt;成对舵机转动固定角度&lt;/p&gt;
&lt;p&gt;单个舵机转动固定角度&lt;/p&gt;
&lt;p&gt;从舵机进行转动，使机械臂进行前进与后退操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;0x07 魔方解法操作对应舵机动作分析&lt;/h5&gt;
&lt;p&gt;因为舵机转动角度为0～180度，所以在初始角度中有两种，可以在0度，使得可以一次性做U和U2类型的操作(关于魔方转法表示，参考详细思考)，魔方解法为上黄下白前橙的初始位置。&lt;/p&gt;
&lt;p&gt;R动作分析如下：2f号舵机旋转到90度，延迟等待旋转完毕，2b号舵机旋转，使机械臂后退，延迟等待旋转完毕，2f号舵机旋转到0度，延迟等待旋转完毕，2b号舵机旋转，使机械臂前进卡住魔方。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">admin</dc:creator><pubDate>Fri, 10 Apr 2015 20:18:00 +0200</pubDate><guid>tag:,2015-04-10:dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-Ruanjiansheji.html</guid><category>电子设计</category><category>解魔方机器人</category></item><item><title>基于LM3S615的解魔方机器人组装调试</title><link>dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-Zhuzhuangtiaoshi.html</link><description>&lt;h5&gt;0x01 LM3S615&lt;/h5&gt;
&lt;p&gt;此板是属于TI公司LM3S系列，是ARM Cortex-M3内核，相关手册以及电路图、说明书也在&lt;a href="http://download"&gt;&lt;/a&gt;有下载，主要使用20针JTAG接口与J-LINK仿真器进行连接调试，主要有关系的是LM3S615的串口通信，PWM模块和GPIO接口。&lt;/p&gt;
&lt;h5&gt;0x02 TTL与RS-232&lt;/h5&gt;
&lt;p&gt;波特率&lt;/p&gt;
&lt;h5&gt;0x03 GPIO&lt;/h5&gt;
&lt;p&gt;第一次接触GPIO是在树莓派上，可以利用其进行一些输入或者输出的控制。&lt;/p&gt;
&lt;h5&gt;0x04 舵机控制板&lt;/h5&gt;
&lt;p&gt;采用的是普通Arduino24路舵机控制板V4.21，可以通过单片机、Arduino、蓝牙模块等控制舵机。详细说明在&lt;a href=""&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;舵机控制板如图所示，电源，中间可以使用蓝牙模块进行控制，预留了RXD、TXD、GND以及3.3V或5V&lt;/p&gt;
&lt;h5&gt;0x05 UART串口&lt;/h5&gt;
&lt;h5&gt;0x06 系统控制框图&lt;/h5&gt;
&lt;p&gt;因为甘特图markdown解析器可能不支持，系统控制框图如图所示。&lt;/p&gt;
&lt;h5&gt;0x06 整体结构设计&lt;/h5&gt;
&lt;h5&gt;0x07 机械手的设计&lt;/h5&gt;
&lt;p&gt;CAD截面图如图所示，使用亚克力板进行切割制作&lt;/p&gt;
&lt;h5&gt;0x08 主舵机导轨的设计&lt;/h5&gt;
&lt;h5&gt;0x09 从舵机的处理&lt;/h5&gt;
&lt;h5&gt;0x10 舵机控制板与舵机的测试&lt;/h5&gt;
&lt;p&gt;舵机控制板首先需要考虑电源供电的问题，因为舵机电源需要5V的，是否共地，以及舵机的电流等。&lt;/p&gt;
&lt;p&gt;舵机部分供电采取DC直流5V，&lt;/p&gt;
&lt;p&gt;舵机控制板，先采取笔记本电脑使用usb转串口模块连接，然后利用一些上位机程序，控制舵机的一定角度的旋转，&lt;/p&gt;
&lt;p&gt;舵机控制板的一些指令集：&lt;/p&gt;
&lt;h5&gt;0x11 蓝牙与舵机控制板的连接测试&lt;/h5&gt;
&lt;p&gt;首先需要考虑蓝牙模块供电问题，&lt;/p&gt;
&lt;h5&gt;0x100 参考文献&lt;/h5&gt;
&lt;p&gt;《ARM体系结构与外设接口实战开发》(北京航空航天大学出版社)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">admin</dc:creator><pubDate>Tue, 24 Mar 2015 22:12:00 +0100</pubDate><guid>tag:,2015-03-24:dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-Zhuzhuangtiaoshi.html</guid><category>电子设计</category><category>解魔方机器人</category></item><item><title>基于LM3S615的解魔方机器人详细思考</title><link>dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-Xiangxisikao.html</link><description>&lt;h5&gt;0x01 显示屏大显部分&lt;/h5&gt;
&lt;p&gt;常见的魔方比赛可以&lt;/p&gt;
&lt;h5&gt;0x02 系统设计框图设计&lt;/h5&gt;
&lt;p&gt;主控板采取官方平台LM3S615平台，其供电采取电源适配器转3.3V(5V)，&lt;/p&gt;
&lt;h5&gt;0x03 系统流程图设计&lt;/h5&gt;
&lt;p&gt;首先需要采集魔方，采集颜色信息，将其转换为矩阵表示。然后进行算法求解，计算出算法以后，通过蓝牙等适配器将求解步骤传到下位机，然后下位机连接好魔方，进行控制舵机进行旋转。&lt;/p&gt;
&lt;h5&gt;0x04 电路板设计&lt;/h5&gt;
&lt;p&gt;电路板部分涉及到了通用版。&lt;/p&gt;
&lt;h5&gt;0x05 材料的选择&lt;/h5&gt;
&lt;p&gt;1.魔方：采用5.7CM的标准魔方，以顺滑和容错为标准，适当调整螺丝。
2.蓝牙适配器：现有HC-05和HM-10两种，主要是下位机接收命令的，应该是配置成从机。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">admin</dc:creator><pubDate>Fri, 20 Mar 2015 20:12:00 +0100</pubDate><guid>tag:,2015-03-20:dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-Xiangxisikao.html</guid><category>电子设计</category><category>解魔方机器人</category></item><item><title>基于XXX的解魔方机器人初步设计</title><link>dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-start.html</link><description>&lt;h5&gt;0x01 材料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Android手机(摄像头正常)&lt;/li&gt;
&lt;li&gt;魔方(5.7cm,非地摊货)&lt;/li&gt;
&lt;li&gt;亚克力板(充当底板部分以及部分机械手)&lt;/li&gt;
&lt;li&gt;舵机(因采取四向导轨式，所以大致需要8个舵机)&lt;/li&gt;
&lt;li&gt;舵机控制板？&lt;/li&gt;
&lt;li&gt;xxx控制板。&lt;/li&gt;
&lt;li&gt;开发用的计算机一台(配置好安卓开发环境，以及keil等，本次采用android studio)&lt;/li&gt;
&lt;li&gt;光滑小轮&lt;/li&gt;
&lt;li&gt;螺丝&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;0x02 整体结构&lt;/h5&gt;
&lt;p&gt;整体主要有四种结构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;四向推进式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大部分的解魔方机器人都是这种结构，基本不需要考虑魔方重力的影响，但是需要的舵机较多，控制也较为稳定，机械手的设计只需要考虑与魔方的配合，以及与舵机的连接。示例项目为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;垂直手臂式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种结构主要是将两个机械手垂直，魔方斜向控制，可以采用4个舵机，示例项目为&lt;a href="http://www.baidu.com"&gt;u&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单向旋转式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种结构主要旋转的是正反一个方向或者是，大部分的乐高机器人采取这种。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内嵌中心块式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种结构在解魔方速度上占优势，在有良好的解魔方算法后，可以达到秒级解魔方，有个视频采取这种结构的，只用了两三秒，不需要太多考虑伸缩或者推进。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设计出的结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结构需要同时考虑速度和性能，单向的需要旋转好几次，实际步骤稍微有点多，最快也大致三十秒，慢的也有七八分钟，由于速度上不占优势，所以没考虑这种结构；垂直手臂虽然相对于那种的结构稍微好点，但是机械手的设计还和魔方的重力有关系，重力和魔方与机械手的接触力的合力向下，由于机械部分不是很熟，感觉设计出的机械手不能在转魔方的时候承担重力的分力，也没太多考虑这种结构；内嵌中心块可能需要破坏魔方的结构，并且机械手需要另外找材料，切合度没有太多把握，可能需要将魔方的中心块卸下来，软件算法需要对应好魔方的配色，虽然解法较快，不需要推进后退所需的时间，但是也没太多地去考虑这种结构，&lt;/p&gt;
&lt;p&gt;最后得出的结构为四向导轨式的，然后在机械臂的推进部分与底盘连接的地方又有两种结构，一种类似于导轨式的滑动，另一种配置好塑料条，利用中间的孔将钢轴插入，前进后退。这时需要考虑材料的问题。&lt;/p&gt;
&lt;p&gt;四方给进轴为解魔方的主操作部分，给进轴由旋转主舵机和伸进从舵机两部分组成。主控由exp-xxx组成，后期可以改为arduino或者树莓派，arduino可以进一步降低成本，采用Android手机摄像头作为颜色采集和识别设备。&lt;/p&gt;
&lt;p&gt;整体设计框图：&lt;/p&gt;
&lt;p&gt;闭环控制模型：&lt;/p&gt;
&lt;h5&gt;0x03 机械手结构&lt;/h5&gt;
&lt;h5&gt;0x04 机械臂结构&lt;/h5&gt;
&lt;p&gt;机械臂大致有两种结构，一种是导轨式，另一种利用塑料条辅助进行推进伸缩。&lt;/p&gt;
&lt;h5&gt;0x05 软件算法方面设计&lt;/h5&gt;
&lt;p&gt;软件算法方面，由于计算的是手机的CPU，所以可以有几种思路，先进行类似于字典的大规模匹配，计算出最优解，或者是通过算法计算，计算出18-24步范围解，曾经魔方有一个上帝之数，为20，称任意打乱的魔方最少需要20步可以还原。同时考虑解魔方机器人每秒几步，统计出步数与时间，从而优化结构，升级舵机可以提高解魔方的速度。&lt;/p&gt;
&lt;p&gt;在得到魔方各面的颜色信息后，是先通过数据库进行匹配还是通过算法进行计算，这里有性能方面的问题。&lt;/p&gt;
&lt;p&gt;魔方解法方面，有一个二阶段算法，可以达到22左右的步数，并且较短时间可以计算出来。&lt;/p&gt;
&lt;h5&gt;0x06 软件摄像头部分及采集识别算法设计&lt;/h5&gt;
&lt;p&gt;app软件采集部分，利用手机后置摄像头，可以前期规定魔方的九个方块范围，后期想办法达到自动识别魔方方形，识别完方形以后，进行颜色的识别。&lt;/p&gt;
&lt;p&gt;颜色识别主要使用HSL色彩系，区别于传统的RGB色彩系，HSL更适合识别相关颜色。并且同时注意部分魔方的橙色黄色红色较为相近，注意分别。&lt;/p&gt;
&lt;h5&gt;0x07 材料的选择部分&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;魔方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;魔方采取5.7cm的三阶魔方，因为需要一定的顺滑度，因此不考虑普通的地摊三阶魔方进行主要测试，推荐大雁、国甲、圣手等牌子的魔方，魔方主要需要一定的顺滑度和容错度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;舵机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;舵机的选择，舵机主要采用金属舵机，其他类型的舵机有步进、减速、塑料等，主舵机负责旋转部分，要求的速度和扭矩都比从舵机要求要高，并且需要180度大扭动。以配合进行U2类型的旋转(魔方旋转术语，为上层顺时针旋转180度。)&lt;/p&gt;
&lt;p&gt;从舵机部分，要求扭矩大于3.0Kg/cm，&lt;/p&gt;
&lt;h5&gt;0x08 下位机控制部分&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;测试舵机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主舵机的连接测试。&lt;/p&gt;
&lt;p&gt;从舵机的连接arduino测试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;电路部分整体设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制板：&lt;/p&gt;
&lt;p&gt;仿真器：&lt;/p&gt;
&lt;p&gt;稳压模块：&lt;/p&gt;
&lt;p&gt;舵机：保证6V电压&lt;/p&gt;
&lt;h5&gt;0x09 安卓手机软件设计部分&lt;/h5&gt;
&lt;p&gt;整体采用material design设计，使用Axure等的进行原型设计，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要有以下几个功能：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1.摄像头识别魔方，计算解法，并通过串口传给下位机。&lt;/li&gt;
&lt;li&gt;2.指定或随机打乱公式打乱魔方。&lt;/li&gt;
&lt;li&gt;3.将魔方打出一定的花样，如一定摆放的I Love U，相对来说，高阶好摆图案。&lt;/li&gt;
&lt;li&gt;4.将解魔方所用时间如何显示到大显上。&lt;/li&gt;
&lt;li&gt;5.当三阶魔方完善以后扩展到二阶、四阶、五阶等魔方。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于界面方面的设计：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1.采用material design设计，体现阴影等元素，采取滑动侧边栏，主界面分为三个选项卡:速解魔方，复原历史，计时复原。速解魔方有连接状态显示，蓝牙连接按钮，扫描摄像头，&lt;/li&gt;
&lt;li&gt;2.主要是使用户点击要少，&lt;/li&gt;
&lt;li&gt;3.主要功能为解魔方操作，识别魔方，计时等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;0x10 乐高机器人与之的辨析&lt;/h5&gt;
&lt;p&gt;乐高也有解魔方机器人，并且有专门的颜色传感器，&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">admin</dc:creator><pubDate>Sun, 08 Mar 2015 20:12:00 +0100</pubDate><guid>tag:,2015-03-08:dubuqingfeng.github.io/201503-Rubik's-Cube-Robot-start.html</guid><category>电子设计</category><category>解魔方机器人</category></item><item><title>基于XXX的初步设计</title><link>dubuqingfeng.github.io/201503-RFID-RTLS-RSSI-start.html</link><description>&lt;h5&gt;0x01 RFID定位&lt;/h5&gt;
&lt;p&gt;RFID技术，无线电频率识别，一种利用射频信号自动识别目标对象并获取相关信息的技术。超高频UHF及高频HF的RFID定位技术，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RFID 定位模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;p&gt;组成示意图：&lt;/p&gt;
&lt;p&gt;接口部分：&lt;/p&gt;
&lt;p&gt;电路部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RFID 标签&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分为主动式和被动式两种，主动式又称为有源标签，主动向读写器发送射频信号，被动式标签不带电池，又称为无源标签，其发射电波及内部所需能量来自读写器产生的电磁波，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;天线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类型主要分为偶极子天线、微带贴片天线、线圈天线等&lt;/p&gt;
&lt;p&gt;工作模式：&lt;/p&gt;
&lt;p&gt;技术要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分为软件中间件和硬件中间件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RFID 定位原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;耦合方式分为两种，分为电感耦合(磁耦合)和反向散射耦合(电磁场耦合)两大类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;电感耦合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;射频载波频率为13.56MHz和小于135kHz的频段，工作距离在1m以下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;电磁场耦合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;工作距离在1m以上。&lt;/p&gt;
&lt;h5&gt;0x02 RFID频率的选择&lt;/h5&gt;
&lt;h5&gt;0x03 微波(2.4GHz)相关技术及思考&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;天线设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;0x04 初步设计示意图&lt;/h5&gt;
&lt;h5&gt;0x05 网页端显示&lt;/h5&gt;
&lt;p&gt;通过自己设计的地图模型，以反映现实的具体环境，初期进行2D地图的模拟，逐步发展到2.5D，3D。&lt;/p&gt;
&lt;h5&gt;0x06 微信公众号的对接&lt;/h5&gt;
&lt;p&gt;使用weiphp开源程序进行微信公众平台的对接，可以搭设一些后台。通过实时传回的数据进行小车的定位显示。&lt;/p&gt;
&lt;h5&gt;0x07 相关标准&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;ISO/IEC 18000标准&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是控制空中接口的重要标准，允许的频段有6个，低于135kHz，13.56MHz，433MHz，860-930MHz，2.45GHz，5.8GHz。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ISO/IEC 18001标准&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一定的外形标准&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ISO/IEC 10374标准&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于微波应答器的集装箱识别标准，采用有源标签，&lt;/p&gt;
&lt;h5&gt;0x08 Q&amp;amp;A&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;Question:定位的相关技术及对比？&lt;/p&gt;
&lt;p&gt;Question:读写器与主控的连接方式&lt;/p&gt;
&lt;p&gt;Question:有源标签的信号折射问题.&lt;/p&gt;
&lt;p&gt;Question:读写器天线节点的布置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;0x09 参考文献&lt;/h5&gt;
&lt;p&gt;部分参考《射频识别(RFID)原理与应用》(电子工业出版社)第1，3，4，5，6，9，10章&lt;/p&gt;
&lt;p&gt;《单片机与计算机串口通信实践》第一部分，第二部分第3，4章(单片机，串口通信基础)&lt;/p&gt;
&lt;p&gt;《RFID与传感器网络：架构、协议、安全与集成》(机械工业出版社)第10，19章&lt;/p&gt;
&lt;p&gt;《UHF RFID标签天线设计、仿真及实践》(电子工业出版社)&lt;/p&gt;
&lt;p&gt;《无线射频识别(RFID)技术基础》(北京航空航天大学出版社)&lt;/p&gt;
&lt;p&gt;万方31&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">admin</dc:creator><pubDate>Sat, 07 Mar 2015 11:00:00 +0100</pubDate><guid>tag:,2015-03-06:dubuqingfeng.github.io/201503-RFID-RTLS-RSSI-start.html</guid><category>电子设计</category><category>RFID</category></item></channel></rss>