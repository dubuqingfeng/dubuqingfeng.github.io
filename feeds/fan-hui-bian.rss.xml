<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>独步清风's blog</title><link>dubuqingfeng.github.io/</link><description></description><atom:link href="dubuqingfeng.github.io/feeds/fan-hui-bian.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 28 Jul 2014 20:48:00 +0200</lastBuildDate><item><title>利用VMProtect sdk和ASProtect sdk加密delphi程序</title><link>dubuqingfeng.github.io/posts/2014/%207/28/201407-reverse-disassemble-delphi/index.html</link><description>&lt;h5&gt;0x01 前言&lt;/h5&gt;
&lt;p&gt;普通的一些加密壳能够较为容易的被脱掉，而一些稍微难一点壳，例如VMProtect等，刚入门的新手就不是那么好脱了，而这些壳也提供了一些sdk帮助我们加密需要加密的函数，使保护壳能够识别源码中需要加密保护的代码段。下面以我的一个delphi程序为例，介绍VMProtect sdk和EncryptPE的一些加密方法，其他vc，或者易语言写的程序也可以使用其进行加密。&lt;/p&gt;
&lt;h5&gt;0x02 VMProtect保护&lt;/h5&gt;
&lt;p&gt;VMProtect sdk保护方式可以有两种，map法和标记法，在官方文档中，有下述方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;it is possible by doing the following: use the main menu of the Delphi IDE 
to open the project options (Project – Options) and select the “Detailed” 
option in the “MAP file” group on the “Linker” tab:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-07-28_165101-300x284.jpg" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;将项目设置中map文件的设置从无改成详细。&lt;/p&gt;
&lt;p&gt;可以看到产生了如图的map文件，map文件中包含了有关被链接的程序的下列信息：模块名称，为1文件的基名称，时间戳，来自程序的文件头（不是来自文件系统，程序中的组列表，包括每个组的起始地 址（节：偏移量的形式）、长度、组名和类；公共符号的列表，包括每个地址（节：偏移量的形式）、符号名称、平直地址和包含符号定义的obj文件；入口点（节：偏移量的形式），另外可以通过map文件确定程序奔溃的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-07-28_165224.jpg" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;然后下载VMProtect，官网上是未激活版。本文以注册版演示。&lt;/p&gt;
&lt;p&gt;载入文件后，VMProtect界面如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-07-28_182237-1024x608.jpg" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;VMProtect根据map文件得到了一些函数信息，然后F9即可进行编译加壳，然后会生成后缀为.vmp.exe的保护后的文件，在peid0.95中查壳，结果如图所示。虽然结果为什么都没找到，但是区段中已经有了vmp1，vmp0。可以以vmprotect来进行脱壳等操作。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-07-28_173341.jpg" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;而语句标记法，主要利用了下列语句进行需要保护的代码的标记&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;asm&lt;/span&gt;
&lt;span class="x"&gt;db &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;EB&lt;/span&gt;&lt;span class="x"&gt;,&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;10,’VMProtect begin’,0 //标记开始处.&lt;/span&gt;
&lt;span class="x"&gt;end;&lt;/span&gt;
&lt;span class="x"&gt;//想保护的程序代码&lt;/span&gt;
&lt;span class="x"&gt;asm&lt;/span&gt;
&lt;span class="x"&gt;db &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;EB&lt;/span&gt;&lt;span class="x"&gt;,&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;0E,’VMProtect end’,0 //标记结束处.&lt;/span&gt;
&lt;span class="x"&gt;end;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vc当中标记模式为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; __asm    //标记开始处.
{
_emit 0xEB
_emit 0x10  //jmp 0x10
_emit 0x56  //ascii “VMProtect begin”,0
_emit 0x4D
_emit 0x50
_emit 0x72
_emit 0x6F
_emit 0x74
_emit 0x65
_emit 0x63
_emit 0x74
_emit 0x20
_emit 0x62
_emit 0x65
_emit 0x67
_emit 0x69
_emit 0x6E
_emit 0x00
}
//想保护的程序代码
__asm  //标记结束处.
{
_emit 0xEB
_emit 0x0E   //jmp 0x0e
_emit 0x56   //ascii “VMProtect end”,0
_emit 0x4D
_emit 0x50
_emit 0x72
_emit 0x6F
_emit 0x74
_emit 0x65
_emit 0x63
_emit 0x74
_emit 0x20
_emit 0x65
_emit 0x6E
_emit 0x64
_emit 0x00
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而在官方文档中，有下列例子可供参考，将sdk的动态链接库引入，在lib目录下有相关的dll文件，在library目录下也有相关的库文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Markers are inserted in the code to protect separate sections of the code and also
protect string constants. Markers are calls of imported procedures stored in an external
 DLL (VMProtectSDK32.dll is used for 32-bit applications and VMProtectSDK64.dll is used
for 64-bit applications; VMProtectDDK32.sys and VMProtectDDK64.sys respectively are
used to protect drivers), VMProtectSDK are used hereinafter. Procedures and functions
located in VMProtectSDK do not do anything and serve only as markers by which VMProtect
determines the borders of the protected code. Correspondingly, the beginning and end of a
protected block are marked in the following way:

Delphi
uses VMProtectSDK;
VMProtectBegin(MARKER_NAME);
…
VMProtectEnd;
C/C++
#include “VMProtectSDK.h”
VMProtectBegin(MARKER_NAME);
…
VMProtectEnd();
MASM
include VMProtectSDK.inc
invoke VMProtectBegin,SADD(MARKER_NAME)
…
invoke VMProtectEnd
Visual Basic
Call VarPtr(“VMProtect begin”)
…
Call VarPtr(“VMProtect end”)
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;0x03 VMProtect和ASProtect的混合加密&lt;/h5&gt;
&lt;p&gt;Asprotect也有相关的sdk，也提供了注册机制，主要delphi通过标记语句，{$I filename}，实现文件的引入，它主要有多态变形标记，crc检查标记，外壳完整性检查。不同的标记需要引入不同的文件，例如在多态变形标记中，示例为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Delphiexample&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
 &lt;span class="n"&gt;Procedure&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;begin&lt;/span&gt;
 &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;$I&lt;/span&gt; &lt;span class="n"&gt;Inc&lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="n"&gt;UserPolyBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;inc&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
 &lt;span class="c1"&gt;// some code&lt;/span&gt;
 &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还得引入相关的api，uses  aspr_api;&lt;/p&gt;
&lt;p&gt;如果有map文件时，在软件界面中也可以导入，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-07-28_225304.jpg" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;在保护的时候即可自动识别函数。
试验的程序当先用VMProtect，后用ASProtect时，会出现一个如图文件损坏的对话框，可能是因为区段的问题，无法找到入口。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-07-28_225736.jpg" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;而先用ASProtect，后用VMProtect时，程序正常运行，当然因为加壳的原因，在在线杀毒引擎中有23%的杀软(9/38)报告发现病毒。&lt;/p&gt;
&lt;h5&gt;0x04 MAP文件的结构&lt;/h5&gt;
&lt;p&gt;一开始是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; Start         Length     Name                   Class
 0001:00000000 00050F4CH .text                   CODE
 0002:00000000 000011D8H .data                   DATA
 0002:000011D8 00000BE1H .bss                    BSS
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pe文件的区段:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Detailed map of segments，一些细节方面的东西
Address Publics by Name，然后一些关于函数的偏移量
Line numbers for SysConst(C:\Program Files (x86)\Borland\Delphi7\lib\
sysconst.pas) segment .text SysConst代码中行数的偏移量
Line numbers for Unit1(Unit1.pas) segment .text    代码中行数的偏移量
Line numbers for Project2(C:\Program Files (x86)\Borland\Delphi7\
Projects\Project2.dpr) segment .text
Bound resource files 与之相关的资源文件
Program entry point at 0001:00050EE0  程序入口点
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">admin</dc:creator><pubDate>Mon, 28 Jul 2014 20:48:00 +0200</pubDate><guid>tag:,2014-07-28:dubuqingfeng.github.io/posts/2014/ 7/28/201407-reverse-disassemble-delphi/index.html</guid><category>逆向</category><category>反汇编</category><category>delphi加密</category></item><item><title>c程序的启动过程的反汇编分析</title><link>dubuqingfeng.github.io/posts/2014/%207/24/201407-reverse-disassemble-c-main/index.html</link><description>&lt;h5&gt;0x01  工具准备&lt;/h5&gt;
&lt;p&gt;1.最简c代码一只&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;int main()
{
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.ollydbg&lt;/p&gt;
&lt;p&gt;3.VC++6.0&lt;/p&gt;
&lt;p&gt;4.GCC（mingw）&lt;/p&gt;
&lt;h5&gt;0x02  代码分析&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;int main()
{
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在gcc下，添加-nostdlib编译选项，即链接器不链接标准库，会提示以下错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;D:\Backup\我的文档\src&amp;gt;gcc main.c -nostdlib-o main.exe
C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\ccmSU3wr.o:main.c:(.text+0x9): undefined reference to `__main’
collect2.exe: error: ld returned 1 exit status
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于-nostdlib编译选项，只有命令行指定的项才传递给链接器。标准启动文件和库都不会传递给链接器。该选项隐式打开选项-nostartfiles 和-nodefaultlibs。该选项也可以写作–no-standard-libraries。&lt;/p&gt;
&lt;p&gt;在gcc执行汇编之后，在链接部分，当只打开选项-nostartfiles时，结果正常，未出现错误信息。而在-nodefaultlibs选项中，提示很多错误信息。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-06-14_191805.png" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;说明main函数，依赖了一些系统标准库文件，在链接的时候，需要到了一些函数，例如pre_cpp_init、check_managed_app、pre_c_init、_tmainCRTStartup、_InterlockedCompareExchangePointer、duplicate_ppstrings、WinMainCRTStartup、mainCRTStartup、_mingw_prepare_except_fr_msvcr80_and_higher….&lt;/p&gt;
&lt;p&gt;汇编里面的_main就是C语言里面的main，是因为汇编器和C编译器对符号的命名差一个下划线。&lt;/p&gt;
&lt;p&gt;链接器会在系统标准库文件，类似于/lib/crt2.o的文件中，寻找_start符号，然后在_start中执行创建堆对象，栈，打开系统预先提供的设备，将argv,argc参数传入main函数，然后调用main函数。&lt;/p&gt;
&lt;h5&gt;0x03  vc main函数反汇编分析&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="mi"&gt;00401010&lt;/span&gt;   &lt;span class="n"&gt;push&lt;/span&gt;        &lt;span class="n"&gt;ebp&lt;/span&gt;   &lt;span class="c1"&gt;//在堆栈上保存EBP&lt;/span&gt;
&lt;span class="mi"&gt;00401011&lt;/span&gt;   &lt;span class="n"&gt;mov&lt;/span&gt;         &lt;span class="n"&gt;ebp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;esp&lt;/span&gt; &lt;span class="c1"&gt;//将堆栈当前位置给EBP，以在堆栈结构中存储值时的参考点&lt;/span&gt;
&lt;span class="mi"&gt;00401013&lt;/span&gt;   &lt;span class="n"&gt;sub&lt;/span&gt;         &lt;span class="n"&gt;esp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="c1"&gt;//分配空间&lt;/span&gt;
&lt;span class="mi"&gt;00401016&lt;/span&gt;   &lt;span class="n"&gt;push&lt;/span&gt;        &lt;span class="n"&gt;ebx&lt;/span&gt;  &lt;span class="c1"&gt;//保存数据段值&lt;/span&gt;
&lt;span class="mi"&gt;00401017&lt;/span&gt;   &lt;span class="n"&gt;push&lt;/span&gt;        &lt;span class="n"&gt;esi&lt;/span&gt; &lt;span class="c1"&gt;//源地址指针&lt;/span&gt;
&lt;span class="mi"&gt;00401018&lt;/span&gt;   &lt;span class="n"&gt;push&lt;/span&gt;        &lt;span class="n"&gt;edi&lt;/span&gt; &lt;span class="c1"&gt;//目的地址指针&lt;/span&gt;
&lt;span class="mi"&gt;00401019&lt;/span&gt;   &lt;span class="n"&gt;lea&lt;/span&gt;         &lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="o"&gt;,[&lt;/span&gt;&lt;span class="n"&gt;ebp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;//装入有效地址，用来得到局部变量和函数参数的指针。这里[ebp-40h]就是基地址再向下偏移40h，就是前面说的为本地变量留出的空间的起始地址；将这个值装载入edi寄存器，从而得到局部变量的地址&lt;/span&gt;
&lt;span class="mi"&gt;0040101&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;   &lt;span class="n"&gt;mov&lt;/span&gt;         &lt;span class="n"&gt;ecx&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="c1"&gt;//在ecx寄存器存储10h&lt;/span&gt;
&lt;span class="mi"&gt;00401021&lt;/span&gt;   &lt;span class="n"&gt;mov&lt;/span&gt;         &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;CCCCCCCCh&lt;/span&gt;
&lt;span class="mi"&gt;00401026&lt;/span&gt;   &lt;span class="n"&gt;rep&lt;/span&gt; &lt;span class="n"&gt;stos&lt;/span&gt;    &lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;//初始化局部变量空间,ds:[edi]&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;00401028&lt;/span&gt;   &lt;span class="n"&gt;xor&lt;/span&gt;         &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;0040102&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;   &lt;span class="n"&gt;pop&lt;/span&gt;         &lt;span class="n"&gt;edi&lt;/span&gt; &lt;span class="c1"&gt;//恢复所有寄存器的值&lt;/span&gt;
&lt;span class="mi"&gt;0040102&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;   &lt;span class="n"&gt;pop&lt;/span&gt;         &lt;span class="n"&gt;esi&lt;/span&gt;
&lt;span class="mi"&gt;0040102&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;   &lt;span class="n"&gt;pop&lt;/span&gt;         &lt;span class="n"&gt;ebx&lt;/span&gt;
&lt;span class="mi"&gt;0040102&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;   &lt;span class="n"&gt;mov&lt;/span&gt;         &lt;span class="n"&gt;esp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ebp&lt;/span&gt; &lt;span class="c1"&gt;//恢复堆栈&lt;/span&gt;
&lt;span class="mi"&gt;0040102&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt;   &lt;span class="n"&gt;pop&lt;/span&gt;         &lt;span class="n"&gt;ebp&lt;/span&gt;
&lt;span class="mi"&gt;00401030&lt;/span&gt;   &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="c1"&gt;//返回到源EIP地址&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vc查看调用栈，可以看到在main函数之前，系统还启动了mainCRTStartup函数，这个函数是控制台环境下多字节编码的启动函数。在kernel32.dll中地址7c816fd7处调用了mainCRTStartup函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;main() line 2
mainCRTStartup() line 206 + 25 bytes
KERNEL32! 7c816fd7()
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;0x04 ollydbg反汇编分析&lt;/h5&gt;
&lt;p&gt;Od载入，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-06-14_201002.png" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;堆栈窗口如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-06-14_201011.png" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;通过堆栈，可以看到kelnel32调用了入口函数(mainCRTStartup)，对于od来说，main函数并不是Entry point，而是mainCRTStartup函数。&lt;/p&gt;
&lt;p&gt;一直单步，单步到00401146处，od分析为调用GetVersion函数，获取当前运行平台的版本号，因为是控制台程序，所以获取版本号为ms-dos的版本信息。&lt;/p&gt;
&lt;p&gt;继续单步，单步到0040119E处，单步进入，可以看到有HeapCreate申请堆空间函数，大小由传递的参数决定，并且该call里有HeapDestroy销毁堆函数。因此0040119E为初始化堆空间，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-06-14_202017.png" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;在004011C0处，od分析为GetCommandLineA函数，获取命令行参数信息的首地址。&lt;/p&gt;
&lt;p&gt;进入下面的那个call后，可以看到GetEnvironmentStringsW和GetEnvironmentStrings函数，获取环境变量的首地址，如图所示。以Unicode编码形式返回到寄存器和堆栈中，最后采用WideCharToMultiByte函数将Unicode字符串到一个多字节字符串&lt;/p&gt;
&lt;p&gt;&lt;img src="http://1433-wordpress.stor.sinaapp.com/uploads/2014/07/2014-06-14_202855.png" class="responsive-img"&gt;&lt;/p&gt;
&lt;p&gt;并且后续有参数分析的一些函数，环境变量信息分析，从而得到main函数所需的参数，然后在00402D4B位置，将参数传到main函数中，从而执行main函数中的内容。&lt;/p&gt;
&lt;h5&gt;0x05 后记&lt;/h5&gt;
&lt;p&gt;最近在阅读《c++反汇编与逆向分析技术揭秘》，在阅读到第三章认识启动函数，找到用户入口时，得知main函数之前系统要做一些准备工作，再加上上学期学的C语言程序入口函数不是main函数，而是_start函数，这不禁引发了一些思考，到底编译器在编译和系统执行程序的时候发生了什么，因此想以实例进行一定的分析。在思考的过程中，有些涉及到了编译器的知识，包括它如何工作的，汇编之后又是如何链接的，这一部分内容不太熟悉，这一方面得掌握编译原理的知识，还得学习编译器的相关内容。那些东西还没学，因此不免有一些缺憾。了解反汇编的一些内容，可以更深层次的理解相对底层的一些东西，包括栈，堆和寄存器的数据交换。另外并未使用到神器IDA，利用IDA会更好地静态分析一些函数。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">admin</dc:creator><pubDate>Thu, 24 Jul 2014 15:42:00 +0200</pubDate><guid>tag:,2014-07-24:dubuqingfeng.github.io/posts/2014/ 7/24/201407-reverse-disassemble-c-main/index.html</guid><category>C</category><category>反汇编</category></item></channel></rss>